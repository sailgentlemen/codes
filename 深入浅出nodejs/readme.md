## 异步 I/O

```js
var fs = require("fs");

fs.readFile("path", function (err, file) {
  console.log("读取文件完成");
});
console.log("发起读取文件");
```

## 事件与回调函数

```js
// back end
var http = require("http");
var querystring = require("querstring");

http
  .createServer(function (req, res) {
    var postData = "";
    req.setEncoding("utf8");
    // 侦听请求的data事件
    req.on("data", function (chunk) {
      postData += chunk;
    });
    req.on("end", function () {
      res.end(postData);
    });
  })
  .listen(8080);
console.log("服务器启动完成");

// front end
$.ajax({
  url: "/url",
  method: "POST",
  data: {},
  success: function (data) {},
});
```

## 单线程

弱点：

- 无法利用多核 CPU
- 错误会引起整个应用的退出，应用的健壮性值得考验
- 大量计算占用 CPU 导致无法继续调用异步 I/O

Node 通过 child_process 将大计算量分发到子进程，将任务分解，再通过进程间的事件消息来传递结果。

## 跨平台

Node 是基于 libuv 实现跨平台的。

## Node 的应用场景

- I/O 密集型，Node 面向网络且擅长并行 I/O，能够有效地组织起更多硬件资源，从而提供更好的服务。I/O 密集的优势主要在于 Node 利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。
- 是否不擅长 CPU 密集型业务，CPU 密集型应用给 Node 带来的挑战主要是：由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞 I/O 调用的发，这样既可同时享受到并行异步 I/O 的好处，又能充分利用 CPU。Node 没有提供提供多线程用于计算支持，但可利用 C++扩展来更高效的利用 CPU，甚至还可利用子进程的方式，将计算与 I/O 分离。

## CommonJS 规范

Nod 与浏览器以及 W3C 组织、CommonJS 组织、ECMAScript 之间共同构成了一个繁荣的生态系统。

## CommonJS 的模块规范

1. 模块引用
2. 模块定义
3. 模块标识

## Node 模块的实现

引入模块需要经历的步骤：

1. 路径分析
2. 文件定位
3. 编译执行

模块的分类：

1. 核心模块，由 Node 提供，Node 进程启动时，就已被编译并加载进了内存中，加载时只需要进行路径分析
2. 文件模块，由用户编写，动态加载模块，需要执行上述完整的三个步骤，速度比核心模块慢。

## 核心模块编译过程

Node 采用了 V8 附带的 js2c.py 工具

## 用户体验

随着应用复杂性的增加，情景将会变成 M + N + ... 和 max(M,N,...),同步与异步的优势将会凸显出来。另一方面，随着网站或应用的不断膨胀，数据将分布在多台服务器上，分布式将会是常态。分布也意味着 M 与 N 的值会线性增长，这也会放大异步和同步在性能方面的差异。

只有后端快速响应资源，才能让前端的体验变好。

## 资源分配

计算机发展过程中将组件进行了抽象，分为 I/O 设备和计算设备。

假设业务场景中有一组互不相关的任务需要完成，现在的主流方式有以下两种。

- 单线程串行一次执行
- 多线程并行完成

在计算机资源中，通常 I/O 与 CPU 计算之间是可以并行进行的。添加硬件资源是一种提升服务质量的方式，但它不是唯一的方式。

单线程同步编程模型会因阻塞 I/O 导致硬件资源得不到更优的使用。多线程编程模型也存在编程中的死锁、状态同步等问题。

Node 在两者之间平衡，利用单线程，远离多线程死锁、状态同步等问题；利用异步 I/O，让单线程远离阻塞，以更好地使用 CPU。

为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效地利用 CPU 和 I/。

## 异步 I/O 与非阻塞 I/O

异步与非阻塞听起来似乎是同一回事，从实际效果而言，异步和非阻塞都达到了我们并行 I/O 的目的。但是从计算机内核 I/O 而言，异步/同步和阻塞/非阻塞实际上是两回事。

操作系统内核对于 I/O 只有两种方式：阻塞和非阻塞。在调用阻塞 I/O 时，应用程序需要等待 I/O 完成才返回结果。

阻塞 I/O 造成 CPU 等待 I/O，浪费等待时间，CPU 的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞 I/O。

> 操作系统对计算机进行抽象，将所有输入输出设备抽象为文件。内核在进行文件 I/O 操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行 I/O 调用，需要先打开文件描述符，然后在根据文件描述符去实现文件的数据读写。此处非阻塞 I/O 与阻塞 I/O 的区别在于阻塞 I/O 完成整个获取数据的过程，而非阻塞 I/O 则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。

CPU 轮询判断处理状态，对资源造成浪费。

## 现实的异步 I/O

通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递。

所有计算机资源都被抽象成了文件，在 Node 中，无论是\*nix 还是 Windows 平台，内部完成 I/O 任务的另有线程池。

## 事件循环

在进程启动时，Node 便会创建一个类似于 While(true)的循环，每执行一次循环体的过程为 Tick。每个 Tick 过程就是查看是否有事件待处理，如果有，就取出事件及相关的回调函数。如果存在关联的回调函数就执行它们，然后进入下一个循环，如果不再有事件处理，就退出进程。

在 Windows 下，这个循环基于 IOCP 创建，而在\*nix 下则是基于多线程创建。

## 请求对象

Node 调用方式：从 JavaScript 调用 Node 的核心模块，核心模块调用 C++内建模块，内建模块通过 libuv 进行系统调用。

Nodes 是线程池实现异步 I/O

## 异步 IO 关键词

单线程、事件循环、观察者和 I/O 线程。

在 Node 中，除了 JavaScript 是单线程外，Node 自身其实是多线程的，只是 I/O 线程使用的 CPU 较少，除了用户代码无法并行，所有的 I/O 则是可以并行起来的。

## 发布/订阅

考虑健壮性，Node 对发布/订阅机制做了一些额外的处理。

- 对一个事件添加超过了 10 个侦听器，将会得到一些警告，emitter.setMaxListeners(0)可移除限制
- 为了处理异常，EventEmitter 对象对 error 事件进行了特殊处理。如果运行期间的错误触发了 error 事件，EventEmitter 会检查是否有对 error 事件添加过侦听器。如果添加了，这个错误将交由侦听器处理，否则作为异常抛出。如果外部没有捕获，将会引起线程退出，一个健壮的 EventEmitter 应该对 error 事件做处理。

## Once 解决缓存雪崩

```js
// 缓存雪崩
var select = function (callback) {
  db.select("SQL", function (results) {
    callback(results);
  });
};

// 场景：站点刚启动时，缓存不存在，访问量大时数据库将会涌入大量查询请求
// 添加事件队列
var proxy = new events.EventEmitter();
// 添加状态锁
var status = "ready";
var select = function (callback) {
  // 所有请求都压入事件队列，保证每个请求都被执行，用户将在队列中等待数据即可。
  // once仅在执行一次后便自行移除
  proxy.once("selected", callback);
  if (status === "ready") {
    // 利用状态锁，保证重复查询只有一次
    status = "pending";
    db.select("SQL", function (results) {
      proxy.emit("selected", results);
      status = "ready";
    });
  }
};
```

## 内存控制

在服务端，资源向来是寸土寸金。
V8 作为虚拟机。
Node 通过 JavaScript 使用内存就会发现只能使用部分内存（64 位系统为 1.4GB），导致 Node 无法操作大内存对象，这样在单个 Node 进程的情况下，计算机的内存资源无法得到充足的使用。

在 V8 中，所有的 JavaScript 对象都是通过堆来进行分配的。

```js
porcess.memoryUsage();

// 解除限制，只能在启动时指定，当内存分配超阈值就会引起进程出错
node --max-old-space-size=1700 test.js // MB
node --max-new-space-size=1024 test.js // kb
```

## V8 的内存分代

- 新生代的内存空间，存活时间短的对象
- 老生代的内存空间，存活时间较长或常驻内存的对象

v8 堆大小等于两代之和。

## 内存泄露

尽量不要将内存到缓存，而是将缓存放入外部，例如 redis 等。

## 理解 Buffer

在 Node 中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，还要处理大量二进制数据，JavaScript 自有的字符串远远不能满足这些需求，于是 Buffer 对象应运而生。

## Buffer 结构

Buffer 是一个像 Array 的对象，但它主要用来操作字节。

```js
var buf = new Buffer(100);
console.log(buf.length); // 100
buf[20] = -100;
console.log(buf[20]); // 156
buf[21] = 300;
console.log(buf[21]); // 44
buf[22] = 3.1415;
console.log(buf[22]); // 3
```

## Buffer 内存分配

Buffer 对象的内存分配不是在 V8 的堆内存中，而是在 Node 的 C++层面实现内存申请的。因为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大量的内存申请的系统调用，对操作系统有一定压力。为此 Node 在内存的使用上应用的是 C++层面申请内存，在 JavaScript 中分配内存的策略。

为了高效地使用申请来的内存，Node 采用了 slab 分配机制。slab 是一种动态内存管理机制。

slab 就是一块申请好的固定大小的内存区域。

- full：完全分配状态
- partial: 部分分配状态
- empty: 没有被分配状态

```js
// 分配指定大小的Buffer对象
new Buffer(size);

Buffer.poolSize = 8 * 1024; // 8 KB区分大对象和小对象,以此为单位单元进行内存分配
```

## 网络编程

TCP 与 UDP 都属于网络传输层协议，用于构造高效的网络应用。

## 网络安全

数据传输过程中还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器。
