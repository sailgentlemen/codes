## 微信小程序与 Web 网站在技术层面的主要区别是什么？

小程序不同于浏览器的线程模型，而是独自使用了一套双线程模型。

## 什么是小程序的双线程模型？

理解一个新概念或技术的最好办法就是给它一个参照物。

## 浏览器的线程管理模式

浏览器并不是单线程而是多进程的。

浏览器内部架构很复杂，只不过在处理 GUI 渲染线程和 JavaScript 逻辑脚本线程上用了互斥、阻塞的管理模式。

以 Chrome 为例，Chrome 开启了多个进程，包括浏览器进程、网络进程、GPU 进程等，这些都是通用的进程。

同时 Chrome 为每个标签页开启了独立的渲染进程，每个进程之间资源并不共享，所以即便某个标签页崩溃了也不会影响其他标签页。

而每个标签页进程中，浏览器会把不同的工作交给对应的线程，比如 GUI 渲染线程负责把 HTML 渲染成可视化的 UI；JavaScript 引擎线程负责解析和运行 JavaScript 代码逻辑；定时触发器线程负责处理 setTimeout/setInterval 定时器等。

setTimeout/setInterval 并不是 JavaScript 语言的一部分，而是运行时提供的能力。

其中 GUI 渲染线程和 JavaScript 引擎线程是互斥的，JavaScript 在执行期间会阻塞 UI 的渲染，甚至如果执行时间太长会由于页面长时间无响应然后崩溃，正是 GUI 渲染线程和 JavaScript 引擎线程之间的这种互斥、阻塞的线程管理方式，以至于让我们让我们认为浏览器是单线程的。

为什么 JavaScript 引擎线程和 GUI 线程是互斥的，这是因为 JavaScript 代码有修改 DOM 的权限。

当 JavaScript 代码被执行时，GUI 渲染线程会被挂起，等待 JavaScript 引擎线程空闲时再被执行，以免在渲染期间被 JavaScript 重复地修改 DOM 造成不必要的渲染压力。采用互斥的模式等待 JavaScript 代码执行完毕后，可以保证渲染是最终的执行结果。所以浏览器空闲时长(Idle)也成为了衡量网站性能的重要指标之一，空闲时长多代表 JavaScript 逻辑不密集以及 DOM 改动频率低，这种情况下浏览器可以快速响应用户的操作。

后来，HTML5 引入了 Web Worker，提供多线程执行 JavaScript 代码的能力，但是与其他编程语言不同的是，Worker 线程与主线程并不是扁平的，而是一种主从多线程模型。

Worker 内的 JavaScript 代码不能操作 DOM ，可以将其理解为线程安全的。这也是理解小程序双线程模型的一个重要基础。

## 为什么小程序不使用浏览器的线程模型

小程序的宿主是微信，但是小程序版本的迭代是独立的，升级更新不依赖宿主，这一点跟 Web 网站是相同的。

- 保证线程安全，最直接的不运行操作 DOM
- 性能，根据客户端提供不同的运行 js 沙箱线程，平行并不阻塞 UI 线程
