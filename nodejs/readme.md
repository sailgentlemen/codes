### 模块的加载优先级

1. 系统缓存：模块被执行后会进行缓存，首先就是先进行缓存加载，判断缓存中是否有值。
2. 系统模块： 部分核心模块已经被编译成了二进制，并直接加载进了内存中。
3. 文件模块：优先架子啊.、.. / 开头的文件路径，如果没有带上扩展名，会一次按照 .js .json .node 进行补充尝试，该部分任务将以同步模式执行，从性能优化角度来看，文件模块最好带上扩展名。
4. 目录作为一个模块：将目录当做一个包处理，首先会查找目录下 package.json 文件,确定文件中的 main 字段值，以此为入口文件路径进行加载。
5. node_modules 目录加载：从当前目录开始向根目录查找。

### 对象引用关系考察

> module.exports 与 exports 的却别？

```js
const exports = modules.exports;
```

**exports 不能直接赋值 对象，会得到 undefined**

### 高并发下雪崩

热点数据存放在内存中缓存，高并发场景下，如果缓存失效,就会有大量请求涌入数据库，对数据库造成压力，我们可以使用 once 方法来解决。

### Crypto 加解密模块

> Crypto 加密模块是 C/C++ 实现这些算法后，暴露为 JavaScript 接口的模块，包含对 OpenSSL 的哈希表、HMAC、加密、解密、签名、以及验证功能的一整套封装。

### Cipher

> Cipher 类用于加密数据，属于对称秘钥加密，假设通信双方 A、B 通讯方 A 使用 key 对明文进行加密传输，通讯方 B 接收到密文后，使用同样的 key 进行解密得到明文。

### AES/ECB/PKCS5Padding

- AES: 代表算法
- ECB: 代表模式
- PCKS5Padding: 代表填充量

> 推荐使用 crypto.createCipheriv()， 自动补全填充，Java AES 128 位填充模式自动填充向量（iv）

### MD5

让大容量信息在数字签名软件签署私人秘钥前被“压缩”成一种保密格式，也就是把一个任意长度的字节串变换成一定长度的十六进制数字串(32 个字符)一致性验证

### Buffer

Buffer 用于读取或操作二进制数据流，作为 NodeJS API 的一部分使用时无需 require，用于操作网络协议、数据库、图片和文件 I/O 等一些需要大量二进制数据的场景。Buffer 在创建时大小已经被确定且无法被调整，在内存分布是由 C++ 底层提供的。

### 什么是 Buffer ?

数据的读写进硬盘，是通过缓冲区来进行的。

### 线程和进程

进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单元，是操作系统结构的基础，进程是线程的容器。

进程间资源是独立的，关注点在进程间通信。

线程是操作系统能够进行运算调度的最小单元，一个线程隶属一个进程，一个进程可以拥有多个线程。
多条线程共享同一个进程资源，线程有单线程和多线程之分，例如 JS 和 Java。

### 单线程使用总结

- Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。
- 如果你有需要大量计算，CPU 耗时的操作，开发时要注意。

### 多线程使用总结

多线程的代价还在于创建新的线程和执行期上下文线程的切换开销，由于每创建一个线程就会占用一定的内存，当引用程序并发大了之后，内存将会很快耗尽。与单线程相似，当需要占用一定 CPU 资源时，会造成当前线程阻塞。

线程间资源是共享的，关注点是安全问题，例如全景变量所有线程都可访问修改。

### Nodejs 的线程与进程

高并发应用场景使用 NodeJS 将会是不错的选择，在单核 CPU 系统之上采用单核+单线程的模式开发。在多核 CPU 系统上，可以用 child_process.fork 开启多个进程，即 多进程 + 单线程 模式。

多进程不是为了解决高并发，主要是解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。

### IPC

Inter-process communication，即进程间通信技术，由于每个进程创建之后都有自己的独立空间，实现 IPC 就是为了进程之间资源共享访问，实现 IPC 的方式有很多种：管道、消息队列、信号量、Domain Socket,Nodejs 通过 pipe 来实现。

通信机制：

父进程在创建子进程之前会先创建 IPC 通道并一直监听该通道，之后开始创建子进程并通过环境变量的方式将 IPC 频道的文件描述符传给子进程，子进程启动时根据传递的文件描述符去链接 IPC 通道，从而建立父子进程之间的通信机制。

在浏览器环境中 UI 渲染线程和 JS 执行引擎是互斥的，一方在执行时会导致另一方被挂起，这是由 JS 引擎决定的。

数据共享不应该放置在进程内，而是持久化在数据中。

### 僵尸进程

使用 fork 创建子进程，正常情况进程退出，内核要释放掉进程所占用的资源：打开文件、占用内存等，但是进程的 PID、退出状态、运行时间等会进行保留，直到父进程调用 wait/waitpid 来获取子进程的状态信息时，这些资源才会被释放。

总结：如果子进程退出后，父进程没有调用 wait/waitpid 来获取子进程状态，那么保留的进程号将会被一直占用，且占用系统资源，称之为僵尸进程。

元凶不是僵尸进程而是父进程，所以把父进程杀掉，僵尸进程会被 init=1 进程收养，init 会对这些孤儿进程进行管理，调用 wait/waitpid 释放系统占用资源。

### Net 与 Dgram

tcp 同步序列号

SYN=1,Seq=client_isn
SYN=1,Seq=client_isn,ACK=client_isn+1
SYN=0,Seq=client_isn+1,ACK=server_isn+1

### TCP 粘包问题

为什么客户端连续向服务端发送数据，会收到合并并返回？

客户端在发送之前会将短时间有多个发送的数据块缓冲到一起，形成一个大的数据库一并发送，同样接收端也有一个接收端缓冲器，这样做也是为了减少 I/O 消耗达到性能优化。

### Nodejs DNS 模块两大类别

DNS 模块是基于 UDP 协议来实现的，Node.js DNS 模块分为两大类：一是使用底层操作系统工具进行域名解析，二是链接到一个 DNS 网络服务器执行域名解析。

### Nodejs 的 Cluster 模块采用了哪种集群

- 1 个 Node 实例开启多个端口，通过反向代理服务器向各端口服务进行转发
- 1 个 Node 实例开启多个进程监听同一个端口，通过负载均衡技术分配请求

### CPU 密集型业务

- Node 可以通过编写 C/C++扩展的方式更高效的利用 CPU。
- 通过子进程的方式将一部分 Node 进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与 I/O 分离，这样还能充分利用多 CPU。
