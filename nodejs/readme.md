### 模块的加载优先级

1. 系统缓存：模块被执行后会进行缓存，首先就是先进行缓存加载，判断缓存中是否有值。
2. 系统模块： 部分核心模块已经被编译成了二进制，并直接加载进了内存中。
3. 文件模块：优先架子啊.、.. / 开头的文件路径，如果没有带上扩展名，会一次按照 .js .json .node 进行补充尝试，该部分任务将以同步模式执行，从性能优化角度来看，文件模块最好带上扩展名。
4. 目录作为一个模块：将目录当做一个包处理，首先会查找目录下 package.json 文件,确定文件中的 main 字段值，以此为入口文件路径进行加载。
5. node_modules 目录加载：从当前目录开始向根目录查找。

### 对象引用关系考察

> module.exports 与 exports 的却别？

```js
const exports = modules.exports;
```

**exports 不能直接赋值 对象，会得到 undefined**

### 高并发下雪崩

热点数据存放在内存中缓存，高并发场景下，如果缓存失效,就会有大量请求涌入数据库，对数据库造成压力，我们可以使用 once 方法来解决。

### Crypto 加解密模块

> Crypto 加密模块是 C/C++ 实现这些算法后，暴露为 JavaScript 接口的模块，包含对 OpenSSL 的哈希表、HMAC、加密、解密、签名、以及验证功能的一整套封装。

### Cipher

> Cipher 类用于加密数据，属于对称秘钥加密，假设通信双方 A、B 通讯方 A 使用 key 对明文进行加密传输，通讯方 B 接收到密文后，使用同样的 key 进行解密得到明文。

### AES/ECB/PKCS5Padding

- AES: 代表算法
- ECB: 代表模式
- PCKS5Padding: 代表填充量

> 推荐使用 crypto.createCipheriv()， 自动补全填充，Java AES 128 位填充模式自动填充向量（iv）

### MD5

让大容量信息在数字签名软件签署私人秘钥前被“压缩”成一种保密格式，也就是把一个任意长度的字节串变换成一定长度的十六进制数字串(32 个字符)一致性验证

### Buffer

Buffer 用于读取或操作二进制数据流，作为 NodeJS API 的一部分使用时无需 require，用于操作网络协议、数据库、图片和文件 I/O 等一些需要大量二进制数据的场景。Buffer 在创建时大小已经被确定且无法被调整，在内存分布是由 C++ 底层提供的。

### 什么是 Buffer ?

数据的读写进硬盘，是通过缓冲区来进行的。

### 线程和进程

进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单元，是操作系统结构的基础，进程是线程的容器。

进程间资源是独立的，关注点在进程间通信。

线程是操作系统能够进行运算调度的最小单元，一个线程隶属一个进程，一个进程可以拥有多个线程。
多条线程共享同一个进程资源，线程有单线程和多线程之分，例如 JS 和 Java。

### 单线程使用总结

- Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。
- 如果你有需要大量计算，CPU 耗时的操作，开发时要注意。

### 多线程使用总结

多线程的代价还在于创建新的线程和执行期上下文线程的切换开销，由于每创建一个线程就会占用一定的内存，当引用程序并发大了之后，内存将会很快耗尽。与单线程相似，当需要占用一定 CPU 资源时，会造成当前线程阻塞。

线程间资源是共享的，关注点是安全问题，例如全景变量所有线程都可访问修改。

### Nodejs 的线程与进程

高并发应用场景使用 NodeJS 将会是不错的选择，在单核 CPU 系统之上采用单核+单线程的模式开发。在多核 CPU 系统上，可以用 child_process.fork 开启多个进程，即 多进程 + 单线程 模式。

多进程不是为了解决高并发，主要是解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。


